mq.fun <-
function(filePath,folder){
	# preparing XML
	mqpar.name 	<- 	list.files(paste(path.package("mqqc"),"data",sep ="/"),"mqpar",full.name = T)
	mqpar 		<- 	readLines(mqpar.name)
	xmlNEW 		<- 	xml.replace(c("filePaths"),path.convert(filePath),mqpar)
	xmlNEW 		<- 	xml.replace(c("fileNames"),basename(filePath), xmlNEW)
	xmlNEW 		<- 	xml.replace(c("paramGroups"),rep(1,length(filePath)), xmlNEW,start.string = "<int>",end.string = "</int>")
	# writing XML
	write(xmlNEW,xml.path  <- paste(dirname(filePath),"mqpar.xml",sep = "/"))
	
	# creating string for system call of MQ
	#check MQ path
	checkMQ <- list.files(paste(path.package("mqqc"),"data",sep ="/"),pattern = "MQpath",full.name = T)
	if(length(checkMQ)==0){
		cat("\rChoose MQ Directory!",rep(" ",100))
		MQloop <- T
		require(tcltk)
		while(MQloop){
			
			checkMQ <- tk_choose.dir( caption = "Please select folder containing MQ.")	
			checkMQ.bin <- list.files(paste(checkMQ,"bin",sep = "/"),pattern = "MaxQuantCmd.exe",full.name = T)

			if(length(checkMQ.bin) != 0){
				write(checkMQ,file = paste(path.package("mqqc"),"data","MQpath",sep ="/"))
				MQloop = F
				
			}
		}	
	}else{
		checkMQ.bin <- readLines(checkMQ)
	}
	threads <- 1
	MQ		<- "MaxQuantCmd.exe"
	
	MQcmd <- paste(checkMQ.bin,"/bin/",MQ," ", xml.path," ",threads,sep = "")
	MQcmd <- path.convert(MQcmd)
  # Detecting number of cores
  try(cores <- system("wmic cpu get NumberOfCores",intern = T))
  if(exists("cores")){
	  cores <- as.numeric(unlist(strsplit(cores,"")))
    cores <- cores[!is.na(cores)]
    if(length(cores) == 0){
      cores <- 1
    }
  }else{
    cores <- 1
  }  
  
	MQmanager(MQcmd,folder)
  if(systemReport==0){
    catFun(paste("started MQ",basename(filePath)))
  }else{
    
    cat(paste("\nunsuccessfull MQ start:",MQcmd,"\n"))
  }
	#convert slashes to backslashes
}
